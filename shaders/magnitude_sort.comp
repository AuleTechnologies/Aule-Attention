#version 450

// Magnitude-Based Sort Shader
// Sorts keys by their L2 norm (magnitude), which correlates with attention importance.
// Research shows that high-magnitude keys receive more attention on average.

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint num_elements;
    uint shift;         // For radix sort passes: 0, 8, 16, 24
    uint sort_dim;      // Unused for magnitude sort, kept for API compatibility
    uint d_model;       // Embedding dimension
    uint num_segments;  // Number of segments (batch * heads)
    uint segment_size;  // Elements per segment (seq_len)
};

// Input Keys [N, D] - flattened
layout(std430, set = 0, binding = 0) readonly buffer InputKeys {
    float keys[];
};

// Output: Sort keys (magnitudes converted to sortable uint)
layout(std430, set = 0, binding = 3) writeonly buffer OutputSortKeys {
    uint sort_keys[];
};

// Input Indices (current permutation)
layout(std430, set = 0, binding = 2) readonly buffer InputInds {
    uint inds[];
};

// Float to Radix Uint conversion for DESCENDING sort of positive floats
// For magnitude (always positive), we want higher values to sort FIRST
// Radix sort puts smaller uint values first, so we invert the bits
uint floatToRadixDescending(float f) {
    uint u = floatBitsToUint(f);
    // For positive floats: flip sign bit to get correct unsigned ordering
    // Then invert all bits to reverse the sort order (high magnitude first)
    return ~(u ^ 0x80000000);
}

void main() {
    uint gID = gl_GlobalInvocationID.x;

    if (gID >= num_elements) return;

    // Determine segment from global ID (not workgroup)
    // Each segment has segment_size elements
    uint segment_id = gID / segment_size;
    uint local_pos = gID % segment_size;  // Position within segment

    // Get current index (from previous sort pass or iota)
    // inds[gID] contains the local index within the segment
    uint local_idx = inds[gID];

    // Calculate actual key offset
    uint segment_start = segment_id * segment_size;
    uint key_idx = segment_start + local_idx;
    uint key_offset = key_idx * d_model;

    // Compute magnitude (L2 norm squared - sqrt is monotonic so we skip it)
    float mag_sq = 0.0;

    // Full magnitude computation for accuracy
    // For very large d_model, could sample but full is more accurate
    uint actual_d = min(d_model, 128u); // Cap for performance

    for (uint i = 0; i < actual_d; i++) {
        float v = keys[key_offset + i];
        mag_sq += v * v;
    }

    // Convert to sortable uint (descending - high magnitude first)
    uint radix_key = floatToRadixDescending(mag_sq);

    // Store for radix sort
    sort_keys[gID] = radix_key;
}
