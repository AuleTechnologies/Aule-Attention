#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint num_elements;
    uint shift;     // 0, 8, 16, 24
    uint sort_dim;  // Stride or dimension index
    uint d_model;   // Total dimensions for stride calculation
    uint num_segments;
    uint segment_size;
};

// Input Keys
layout(std430, set = 0, binding = 0) readonly buffer InputKeys {
    float keys[];
};

// Global Histograms
// Layout: [NUM_SEGMENTS * WORKGROUPS_PER_SEGMENT * 256]
layout(std430, set = 0, binding = 6) coherent buffer Histograms {
    uint global_histograms[];
};

// Input Indices (for stable sort passes)
layout(std430, set = 0, binding = 2) readonly buffer InputInds {
    uint inds[];
};

// ...

// Shared memory for local histogram
shared uint local_histogram[256];

// Float to Radix Uint conversion (approximates ordering)
uint floatToRadix(float f) {
    uint u = floatBitsToUint(f);
    uint mask = -int(u >> 31) | 0x80000000;
    return u ^ mask;
}

// Main logic
void main() {
    uint gID = gl_GlobalInvocationID.x;
    uint lID = gl_LocalInvocationID.x;
    uint wID = gl_WorkGroupID.x;
    
    // ... Segment ID Calculation ...
    uint blocks_per_seg = segment_size / 256;
    if (blocks_per_seg == 0) blocks_per_seg = 1;

    uint segment_id = wID / blocks_per_seg;
    // uint logical_block_id = wID % blocks_per_seg; // Unused for now

    // Initialize shared memory
    local_histogram[lID] = 0;
    barrier();

    if (gID < num_elements) {
        // Fetch Key indirectly via Indices
        uint original_idx = inds[gID];
        
        // Offset by Segment Start because inds are Local (0..S-1)
        uint segment_start = segment_id * segment_size; 
        uint key_idx = segment_start + original_idx;
        
        float val = keys[key_idx * d_model + sort_dim];
        
        uint radix_val = floatToRadix(val);
        uint digit = (radix_val >> shift) & 0xFF;
        
        // Force Logic for Verification (Step 1487)
        // If shift==0. 1.0 vs 1.0+eps.
        // floatToRadix(1.0) -> Ends in ...0000.
        // floatToRadix(1.0|1) -> Ends in ...0001.
        // So Digit 0 vs Digit 1.
        // We don't need FORCE logic if Iota is correct.
        // But let's KEEP FORCE LOGIC for deterministic Needles?
        // No, verifying REAL sort is better now.
        // Remove Force Logic.
        
        atomicAdd(local_histogram[digit], 1);
    }
    
    barrier();
    
    // Write to Global Histograms
    global_histograms[wID * 256 + lID] = local_histogram[lID];
}
