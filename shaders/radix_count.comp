#version 450

// Radix Count Shader - counts occurrences of each radix digit
// Now reads pre-computed sort keys from binding 3 (set by magnitude_sort.comp)

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint num_elements;
    uint shift;     // 0, 8, 16, 24
    uint sort_dim;  // Unused when using pre-computed sort keys
    uint d_model;   // Unused when using pre-computed sort keys
    uint num_segments;
    uint segment_size;
};

// Pre-computed Sort Keys (from magnitude_sort.comp or projection)
// Already in radix-sortable uint format
layout(std430, set = 0, binding = 3) readonly buffer SortKeys {
    uint sort_keys[];
};

// Global Histograms
// Layout: [NUM_SEGMENTS * WORKGROUPS_PER_SEGMENT * 256]
layout(std430, set = 0, binding = 6) coherent buffer Histograms {
    uint global_histograms[];
};

// Input Indices (for stable sort passes)
layout(std430, set = 0, binding = 2) readonly buffer InputInds {
    uint inds[];
};

// Shared memory for local histogram
shared uint local_histogram[256];

void main() {
    uint gID = gl_GlobalInvocationID.x;
    uint lID = gl_LocalInvocationID.x;
    uint wID = gl_WorkGroupID.x;

    // Segment ID Calculation
    uint blocks_per_seg = segment_size / 256;
    if (blocks_per_seg == 0) blocks_per_seg = 1;

    uint segment_id = wID / blocks_per_seg;

    // Initialize shared memory
    local_histogram[lID] = 0;
    barrier();

    if (gID < num_elements) {
        // Read sort key via current index permutation
        // The sort_keys buffer is indexed by global position
        // On first pass (after iota), inds[gID] == gID % segment_size
        // On subsequent passes, inds reflects partial sort order
        uint radix_val = sort_keys[gID];
        uint digit = (radix_val >> shift) & 0xFF;

        atomicAdd(local_histogram[digit], 1);
    }

    barrier();

    // Write to Global Histograms
    global_histograms[wID * 256 + lID] = local_histogram[lID];
}
