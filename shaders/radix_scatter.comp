#version 450

// Radix Scatter Shader - scatters elements to sorted positions
// Now reads pre-computed sort keys from binding 7

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint num_elements;
    uint shift;     // 0, 8, 16, 24
    uint sort_dim;  // Unused when using pre-computed sort keys
    uint d_model;   // Unused when using pre-computed sort keys
    uint num_segments;
    uint segment_size;
};

// Input State (unused for key/val movement in index-only sort)
layout(std430, set = 0, binding = 0) readonly buffer InputKeys { float keys_in[]; };
layout(std430, set = 0, binding = 1) readonly buffer InputVals { float vals_in[]; };
layout(std430, set = 0, binding = 2) readonly buffer InputInds { uint inds_in[]; };

// Pre-computed Sort Keys (from magnitude_sort.comp)
layout(std430, set = 0, binding = 3) readonly buffer SortKeys { uint sort_keys_in[]; };

// Outputs
layout(std430, set = 0, binding = 4) writeonly buffer OutSortKeys { uint sort_keys_out[]; };
layout(std430, set = 0, binding = 5) writeonly buffer OutInds { uint inds_out[]; };

// Offsets
layout(std430, set = 0, binding = 6) readonly buffer GlobalOffsets {
    uint global_offsets[];
};

shared uint local_histogram[256];
shared uint local_offsets[256];
shared uint shared_digits[256];

void main() {
    uint gID = gl_GlobalInvocationID.x;
    uint lID = gl_LocalInvocationID.x;
    uint wID = gl_WorkGroupID.x;

    // Segment Calculation - use gID for correct segment when segment_size < 256
    uint segment_id = gID / segment_size;
    uint segment_start_idx = segment_id * segment_size;

    // Local Variables
    uint original_idx = 0;
    uint sort_key = 0;
    uint digit = 0;
    uint my_rank = 0;
    bool active_thread = gID < num_elements;

    // Initialize shared memory
    local_histogram[lID] = 0;
    barrier();

    // 1. Read Sort Key & Compute Digit
    if (active_thread) {
        original_idx = inds_in[gID];
        sort_key = sort_keys_in[gID];
        digit = (sort_key >> shift) & 0xFF;
    }

    // 2. Stable Sort Rank Logic
    
    // a. Store digits to shared
    if (active_thread) {
       shared_digits[lID] = digit;
    } else {
       shared_digits[lID] = 9999; // Sentinel
    }
    barrier();
    
    // b. Compute Histogram
    if (active_thread) {
       atomicAdd(local_histogram[digit], 1);
    }
    barrier();
    
    // c. Compute Local Rank (Stable Loop)
    if (active_thread) {
        for (uint i = 0; i < lID; i++) {
            if (shared_digits[i] == digit) {
                my_rank++;
            }
        }
    }
    
    // Scan local_histogram into local_offsets
    if (lID == 0) {
        uint sum = 0;
        for (uint i=0; i<256; i++) {
            local_offsets[i] = sum;
            sum += local_histogram[i];
        }
    }
    barrier();
    
    // 3. Scatter Write (both indices and sort keys for next pass)
    if (active_thread) {
        uint global_offset = global_offsets[wID * 256 + digit];
        uint final_rank = global_offset + my_rank;
        uint out_pos = segment_start_idx + final_rank;
        inds_out[out_pos] = original_idx;
        sort_keys_out[out_pos] = sort_key;
    }
}
