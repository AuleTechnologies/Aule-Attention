#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint num_elements;
    uint shift;     // 0, 8, 16, 24
    uint sort_dim;
    uint d_model;
    uint num_segments;
    uint segment_size;
};

// Input State
layout(std430, set = 0, binding = 0) readonly buffer InputKeys { float keys_in[]; };
layout(std430, set = 0, binding = 1) readonly buffer InputVals { float vals_in[]; };
layout(std430, set = 0, binding = 2) readonly buffer InputInds { uint inds_in[]; };

// Outputs
layout(std430, set = 0, binding = 3) writeonly buffer OutKeys { float keys_out[]; };
layout(std430, set = 0, binding = 4) writeonly buffer OutVals { float vals_out[]; };
layout(std430, set = 0, binding = 5) writeonly buffer OutInds { uint inds_out[]; };

// Offsets
layout(std430, set = 0, binding = 6) readonly buffer GlobalOffsets {
    uint global_offsets[];
};

shared uint local_histogram[256];
shared uint local_offsets[256];
shared uint shared_digits[256];

uint floatToRadix(float f) {
    uint u = floatBitsToUint(f);
    uint mask = -int(u >> 31) | 0x80000000;
    return u ^ mask;
}

void main() {
    uint gID = gl_GlobalInvocationID.x;
    uint lID = gl_LocalInvocationID.x;
    uint wID = gl_WorkGroupID.x;
    
    // Segment Calculation
    uint blocks_per_seg = segment_size / 256; 
    if (blocks_per_seg == 0) blocks_per_seg = 1;
    
    uint segment_id = wID / blocks_per_seg;
    uint segment_start_idx = segment_id * segment_size;

    // Local Variables
    uint original_idx = 0;
    uint digit = 0;
    uint my_rank = 0;
    bool active_thread = gID < num_elements;

    // Initialize shared memory
    local_histogram[lID] = 0;
    barrier();
    
    // 1. Read Key & Compute Digit
    if (active_thread) {
        original_idx = inds_in[gID];
        
        // Offset by Segment Start because inds are Local
        uint key_idx = segment_start_idx + original_idx;
        
        float key_val = keys_in[key_idx * d_model + sort_dim];
        uint radius_val = floatToRadix(key_val);
        digit = (radius_val >> shift) & 0xFF; // Only need 8 bits
    }

    // 2. Stable Sort Rank Logic
    
    // a. Store digits to shared
    if (active_thread) {
       shared_digits[lID] = digit;
    } else {
       shared_digits[lID] = 9999; // Sentinel
    }
    barrier();
    
    // b. Compute Histogram
    if (active_thread) {
       atomicAdd(local_histogram[digit], 1);
    }
    barrier();
    
    // c. Compute Local Rank (Stable Loop)
    if (active_thread) {
        for (uint i = 0; i < lID; i++) {
            if (shared_digits[i] == digit) {
                my_rank++;
            }
        }
    }
    
    // Scan local_histogram into local_offsets
    if (lID == 0) {
        uint sum = 0;
        for (uint i=0; i<256; i++) {
            local_offsets[i] = sum;
            sum += local_histogram[i];
        }
    }
    barrier();
    
    // 3. Scatter Write
    if (active_thread) {
        uint global_offset = global_offsets[wID * 256 + digit];
        uint final_rank = global_offset + my_rank;
        inds_out[segment_start_idx + final_rank] = original_idx;
    }
}
